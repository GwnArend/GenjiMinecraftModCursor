   1: package com.example.genji.events;
   2: 
   3: import com.example.genji.capability.GenjiDataProvider;
   4: import com.example.genji.config.GenjiConfig;
   5: import com.example.genji.network.ModNetwork;
   6: import com.example.genji.network.packet.S2CStartDash;
   7: import com.example.genji.registry.ModSounds;
   8: import net.minecraft.core.particles.ParticleTypes;
   9: import net.minecraft.server.MinecraftServer;
  10: import net.minecraft.server.level.ServerLevel;
  11: import net.minecraft.server.level.ServerPlayer;
  12: import net.minecraft.sounds.SoundSource;
  13: import net.minecraft.world.damagesource.DamageSource;
  14: import net.minecraft.world.entity.Entity;
  15: import net.minecraft.world.entity.LivingEntity;
  16: import net.minecraft.world.level.ClipContext;
  17: import net.minecraft.world.phys.AABB;
  18: import net.minecraft.world.phys.BlockHitResult;
  19: import net.minecraft.world.phys.HitResult;
  20: import net.minecraft.world.phys.Vec3;
  21: 
  22: import java.util.*;
  23: 
  24: /**
  25:  * Smooth-looking dash via multiple server teleports (no easing, sudden stop at end).
  26:  * Damages entities along the path and spawns a subtle trail each tick.
  27:  */
  30: 
  31:     // Feel
  32:     private static final double RANGE = 15.0;         // blocks
  33:     private static final int    DURATION_TICKS = 8;  // more steps = smoother (no easing)
  34:     private static final double HIT_RADIUS = 1.5;    // dash hit cylinder half-width
  36: 
  37:     private static final Map<UUID, DashState> ACTIVE = new HashMap<>();
  38: 
  42: 
  43:     /** Check if a player is currently dashing. */
  45:         return ACTIVE.containsKey(sp.getUUID());
  47: 
  48:     /** Called from packet to start a dash if cooldown allows. */
  50:         var data = GenjiDataProvider.get(sp);
  51:         if (!data.tryDash()) return; // cooldown gate
  52: 
  53:         // Compute endpoint along crosshair up to RANGE, stop just before collision
  54:         Vec3 eye = sp.getEyePosition();
  55:         Vec3 look = sp.getLookAngle().normalize();
  56:         Vec3 wanted = eye.add(look.scale(RANGE));
  57:         ServerLevel level = sp.serverLevel();
  58: 
  59:         HitResult hr = level.clip(new ClipContext(
  60:                 eye, wanted,
  61:                 ClipContext.Block.COLLIDER, ClipContext.Fluid.NONE,
  62:                 sp
  63:         ));
  64: 
  65:         Vec3 end;
  67:             BlockHitResult bhr = (BlockHitResult) hr;
  68:             end = bhr.getLocation().subtract(look.scale(0.35)); // avoid clipping into the block
  70:             end = wanted;
  72: 
  73:         // Keep Y sane
  74:         end = new Vec3(end.x, Math.max(level.getMinBuildHeight() + 1, end.y), end.z);
  75: 
  76:         // Calculate actual distance and scale duration accordingly
  77:         Vec3 startPos = sp.position();
  78:         double actualDistance = startPos.distanceTo(end);
  79:         double distanceRatio = actualDistance / RANGE;
  80:         int scaledDuration = Math.max(2, (int)(DURATION_TICKS * distanceRatio)); // Min 2 ticks
  81: 
  82:         DashState state = new DashState(startPos, end, scaledDuration, 0, new HashSet<>());
  83:         ACTIVE.put(sp.getUUID(), state);
  84: 
  85:         // Send dash info to client for smooth interpolation
  86:         ModNetwork.CHANNEL.sendTo(
  87:             new S2CStartDash(startPos, end, scaledDuration),
  88:             sp.connection.connection,
  89:             net.minecraftforge.network.NetworkDirection.PLAY_TO_CLIENT
  90:         );
  91: 
  92:         // Audio & prep
  93:         level.playSound(null, sp, ModSounds.DASH.get(), SoundSource.PLAYERS, 2.0f, 1.0f);
  94:         sp.setDeltaMovement(Vec3.ZERO);
  95:         sp.hurtMarked = true;
  96:         sp.fallDistance = 0;
  97: 
  98:         // Small starting burst of particles
  99:         spawnStartBurst(level, sp.position(), sp.getLookAngle());
 101: 
 102:     /** Drive active dashes. Call once per server tick (ServerTicks hooks this). */
 104:         if (ACTIVE.isEmpty()) return;
 105: 
 106:         List<UUID> done = new ArrayList<>();
 107: 
 109:             UUID id = entry.getKey();
 110:             DashState st = entry.getValue();
 111: 
 112:             ServerPlayer sp = server.getPlayerList().getPlayer(id);
 114:                 done.add(id);
 115:                 continue;
 117: 
 118:             // Linear interpolation (no easing) â†’ sudden stop at end
 119:             double t0 = (double) st.tick / st.total;
 120:             double t1 = (double) (st.tick + 1) / st.total;
 121: 
 122:             Vec3 prev = lerp(st.start, st.end, t0);
 123:             Vec3 next = lerp(st.start, st.end, t1);
 124: 
 125:             // Teleport a small step forward
 126:             sp.connection.teleport(next.x, next.y, next.z, sp.getYRot(), sp.getXRot());
 127:             sp.setDeltaMovement(Vec3.ZERO);
 128:             sp.hurtMarked = true;
 129:             sp.fallDistance = 0;
 130: 
 131:             // Damage entities swept by this segment (once per target)
 132:             damageAlongSegment(sp, prev, next, st.hit);
 133: 
 134:             // Trail along this step to sell continuity
 135:             spawnStepTrail(sp.serverLevel(), prev, next);
 136: 
 137:             ACTIVE.put(id, st.advance());
 139:                 done.add(id); // hard stop at final tick
 142: 
 143:         done.forEach(ACTIVE::remove);
 145: 
 147:         return new Vec3(
 148:                 a.x + (b.x - a.x) * t,
 149:                 a.y + (b.y - a.y) * t,
 150:                 a.z + (b.z - a.z) * t
 151:         );
 153: 
 155:         ServerLevel level = sp.serverLevel();
 156:         AABB box = new AABB(from, to).inflate(HIT_RADIUS, HIT_RADIUS * 0.6, HIT_RADIUS);
 157:         List<Entity> targets = level.getEntities(sp, box, e ->
 158:                 e.isAlive() && e.isAttackable() && e != sp && !alreadyHit.contains(e.getUUID()));
 159:         if (targets.isEmpty()) return;
 160: 
 161:         DamageSource src = level.damageSources().playerAttack(sp);
 163:             if (!e.isAlive()) continue;
 164:             
 165:             // Deal damage
 166:             boolean wasAlive = e.isAlive();
 167:             e.hurt(src, getDamage());
 168:             alreadyHit.add(e.getUUID());
 169:             
 170:             // Check if damage was actually dealt and send hit sound
 172:                 System.out.println("DASH: Damage dealt, sending hit sound"); // Debug log
 173:                 
 174:                 // Get player data to check nano status
 176:                     boolean isNanoActive = data.isNanoActive();
 177:                     
 178:                     // Always play shuriken hit sounds for dash (normal or nano based on status)
 179:                     System.out.println("DASH: Sending shuriken hit sound, nano: " + isNanoActive); // Debug log
 180:                     String soundType = isNanoActive ? "shuriken_nano" : "shuriken";
 181:                     com.example.genji.network.ModNetwork.CHANNEL.sendTo(
 182:                         new com.example.genji.network.packet.S2CPlayHitSound(soundType), 
 183:                         sp.connection.connection, 
 184:                         net.minecraftforge.network.NetworkDirection.PLAY_TO_CLIENT
 185:                     );
 190: 
 192:         // Bigger burst at start with fast-dissipating green particles
 194:             double s = 0.15 + i * 0.02;
 195:             // Composter particles (green) - dissipate very quickly
 196:             level.sendParticles(ParticleTypes.COMPOSTER,
 197:                     pos.x, pos.y + 0.5, pos.z,
 198:                     2, dir.x * s, dir.y * s, dir.z * s, 0.1);
 201: 
 203:         // Green composter particles with fast dissipation
 204:         double dx = to.x - from.x, dy = to.y - from.y, dz = to.z - from.z;
 205:         int steps = 6;
 207:             double t = i / (double) (steps + 1);
 208:             double px = from.x + dx * t;
 209:             double py = from.y + dy * t + 0.5;
 210:             double pz = from.z + dz * t;
 211:             
 212:             // Composter particles (green) - dissipate quickly, bigger spread
 213:             level.sendParticles(ParticleTypes.COMPOSTER,
 214:                     px, py, pz,
 215:                     3, 0.15, 0.15, 0.15, 0.05);
